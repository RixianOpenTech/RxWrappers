using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FunctoidWrapperGenerator;

[Generator]
public class HelloSourceGenerator : ISourceGenerator
{
    private const string FunctoidAttributeName = "Functoid";

    public void Execute(GeneratorExecutionContext context)
    {
        // Find the main method
        _ = context.Compilation.GetEntryPoint(context.CancellationToken);

        //_ = Debugger.Launch();
        ImmutableArray<MethodDeclarationSyntax> methods = GetFunctoidMethods(context.Compilation);


        Dictionary<(string ns, string cls), List<string>> wrappedMethods = new();
        foreach (MethodDeclarationSyntax method in methods)
        {
            //_ = System.Diagnostics.Debugger.Launch();
            (string, string) reference = ($"{(method.Parent.Parent as NamespaceDeclarationSyntax)?.Name ?? (method.Parent.Parent as FileScopedNamespaceDeclarationSyntax)?.Name}", $"{(method.Parent as ClassDeclarationSyntax).Identifier}");
            string methodWrapped = WrapMethod(method);

            if (wrappedMethods.ContainsKey(reference) is false)
            {
                wrappedMethods[reference] = new List<string>();
            }

            wrappedMethods[reference].Add(methodWrapped);
        }

        foreach (KeyValuePair<(string ns, string cls), List<string>> method in wrappedMethods)
        {
            string wrapped = string.Join($"{Environment.NewLine}{Environment.NewLine}        ", method.Value);
            // Build up the source code
            string source = method.Key.ns == ""
                ? $@"// <auto-generated/>
using System;
using System.Reactive;
using System.Reactive.Linq;
using Functoids.Common;

public static partial class {method.Key.cls}
{{
    {wrapped}
}}
"
                : $@"// <auto-generated/>
using System;
using System.Reactive;
using System.Reactive.Linq;
using Functoids.Common;

namespace {method.Key.ns}
{{
    public static partial class {method.Key.cls}
    {{
        {wrapped}
    }}
}}
";
            //string typeName = mainMethod.ContainingType.Name;

            // Add the source code to the compilation
            context.AddSource($"{method.Key.cls}.g.cs", source);
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required for this one
    }

    private static string WrapMethod(MethodDeclarationSyntax method)
    {
        string parameters = string.Join($", ", method.ParameterList.Parameters.Select(p => $"IObservable<{p.Type}> {p.Identifier.ValueText}"));
        string parameterNames = string.Join($", ", method.ParameterList.Parameters.Select(p => p.Identifier.ValueText));
        string methodCallParams = string.Join($", ", method.ParameterList.Parameters.Select((p, i) => $"t.Item{i + 1}"));

        //_ = System.Diagnostics.Debugger.Launch();
        MethodType methodType = method.Modifiers.Any(SyntaxKind.StaticKeyword) switch
        {
            true => MethodType.Static,
            false => MethodType.Instance,
        };

        ParamCount paramCount = method.ParameterList.Parameters.Count switch
        {
            > 1 => ParamCount.Many,
            1 => ParamCount.One,
            _ => ParamCount.Zero,
        };

        // if (((method.Parent.Parent as NamespaceDeclarationSyntax)?.Name ?? (method.Parent.Parent as FileScopedNamespaceDeclarationSyntax)?.Name)?.ToString() == "Functoids.TestService")
        // {
        //     _ = System.Diagnostics.Debugger.Launch();
        // }

        ReturnType GetReturnType()
        {
            if (method.ReturnType.IsKind(SyntaxKind.VoidKeyword))
            {
                return ReturnType.Void;
            }
            else if (method.ReturnType.IsKind(SyntaxKind.PredefinedType))
            {
                if ((bool)((method.ReturnType as PredefinedTypeSyntax)?.Keyword.IsKind(SyntaxKind.VoidKeyword)))
                {
                    return ReturnType.Void;
                }
            }
            else if (method.ReturnType.IsKind(SyntaxKind.TupleType))
            {
                return ReturnType.Tuple;
            }
            else if (method.ReturnType.IsKind(SyntaxKind.NullableType) && method.ReturnType is NullableTypeSyntax nts)
            {
                if (nts.ElementType is GenericNameSyntax gns && gns.Identifier.ValueText == "Task")
                {
                    List<SyntaxNode> children = gns.TypeArgumentList?.ChildNodes()?.ToList();
                    return children.Count switch
                    {
                        0 => ReturnType.TaskVoid,
                        _ => children.First() switch
                        {
                            TupleTypeSyntax => ReturnType.TaskTuple,
                            _ => ReturnType.TaskSingle
                        }
                    };
                }
                else if (nts.ElementType is IdentifierNameSyntax ins && ins.Identifier.ValueText == "Task")
                {
                    return ReturnType.TaskVoid;
                }
            }

            return ReturnType.Single;

            //ReturnType returnTypeInfo = kind switch
            //{
            //    SyntaxKind.VoidKeyword => ReturnType.Void,
            //    SyntaxKind.TupleType => ReturnType.Tuple,
            //    SyntaxKind.PredefinedType and ((method.ReturnType as PredefinedTypeSyntax) ?.Keyword.Kind() == SyntaxKind.VoidKeyword)
            //    _ => ReturnType.Single,
            //};
        }

        ReturnType returnTypeInfo = GetReturnType();

        string returnType = returnTypeInfo switch
        {
            ReturnType.Void => "Unit",
            ReturnType.Single => method.ReturnType.ToString(),
            ReturnType.Tuple => $"({string.Join(", ", (method.ReturnType as TupleTypeSyntax)?.ChildNodes()?.Cast<TupleElementSyntax>()?.Select(r => $"IObservable<{r.Type}> {r.Identifier}") ?? new string[] { })})",
            ReturnType.TaskVoid => "Unit",
            ReturnType.TaskSingle => ((method.ReturnType as NullableTypeSyntax)?.ElementType as GenericNameSyntax)?.TypeArgumentList?.ChildNodes().First()?.ToString() ?? method.ReturnType.ToString(),
            ReturnType.TaskTuple => $"({string.Join(", ", (((method.ReturnType as NullableTypeSyntax)?.ElementType as GenericNameSyntax)?.TypeArgumentList?.ChildNodes()?.First() as TupleTypeSyntax)?.ChildNodes()?.Cast<TupleElementSyntax>()?.Select(r => $"IObservable<{r.Type}> {r.Identifier}") ?? new string[] { })})",
        };

        //ReturnType returnTypeInfo = method.ReturnType.ToString() switch
        //{
        //    "void" => ReturnType.Void,
        //    _ => ReturnType.Single,
        //};

        string qualifiedPrefix = null;

        switch (methodType)
        {
            case MethodType.Static:
                qualifiedPrefix = $"{(method.Parent.Parent as NamespaceDeclarationSyntax)?.Name ?? (method.Parent.Parent as FileScopedNamespaceDeclarationSyntax)?.Name}.{(method.Parent as ClassDeclarationSyntax).Identifier}";
                break;
            case MethodType.Instance:
                _ = parameters.Insert(0, $"this {(method.Parent as ClassDeclarationSyntax).Identifier} __source, ");
                qualifiedPrefix = "__source";
                break;
        }

        string methodString = (paramCount, returnTypeInfo) switch
        {
            (ParamCount.One, ReturnType.Single) => @$"public static IObservable<{returnType}> {method.Identifier}_Obs({parameters})
        {{
            return {parameterNames}.Select(t => {qualifiedPrefix}.{method.Identifier}(t));
        }}",
            (ParamCount.Many, ReturnType.Single) => @$"public static IObservable<{returnType}> {method.Identifier}_Obs({parameters})
        {{
            return ObservableEx.Zip({parameterNames}).Select(t => t.ToTuple()).Select(t => {qualifiedPrefix}.{method.Identifier}({methodCallParams}));
        }}",
            (ParamCount.Zero, ReturnType.Single) => @$"public static IObservable<{returnType}> {method.Identifier}_Obs()
        {{
            return ObservableExt.Factory(() => {qualifiedPrefix}.{method.Identifier}());
        }}",


            (ParamCount.One, ReturnType.Void) => @$"public static IObservable<Unit> {method.Identifier}_Obs({parameters})
        {{
            return {parameterNames}.Select(t => 
            {{
                {qualifiedPrefix}.{method.Identifier}(t);
                return Unit.Default;
            }});
        }}",
            (ParamCount.Many, ReturnType.Void) => @$"public static IObservable<Unit> {method.Identifier}_Obs({parameters})
        {{
            return ObservableEx.Zip({parameterNames}).Select(t => t.ToTuple()).Select(t => 
            {{
                {qualifiedPrefix}.{method.Identifier}({methodCallParams});
                return Unit.Default;
            }});
        }}",
            (ParamCount.Zero, ReturnType.Void) => @$"public static IObservable<Unit> {method.Identifier}_Obs()
        {{
            return ObservableExt.Factory(() => {qualifiedPrefix}.{method.Identifier}());
        }}",


            (ParamCount.One, ReturnType.Tuple) => @$"public static {returnType} {method.Identifier}_Obs({parameters})
        {{
            return {parameterNames}.Select(t => {qualifiedPrefix}.{method.Identifier}(t)).Unzip();
        }}",
            (ParamCount.Many, ReturnType.Tuple) => @$"public static {returnType} {method.Identifier}_Obs({parameters})
        {{
            return ObservableEx.Zip({parameterNames}).Select(t => t.ToTuple()).Select(t => {qualifiedPrefix}.{method.Identifier}({methodCallParams})).Unzip(replay: true);
        }}",
            (ParamCount.Zero, ReturnType.Tuple) => @$"public static {returnType} {method.Identifier}_Obs()
        {{
            return ObservableExt.Factory(() => {qualifiedPrefix}.{method.Identifier}()).Unzip();
        }}",


            (ParamCount.One, ReturnType.TaskSingle) => @$"public static IObservable<{returnType}> {method.Identifier}_Obs({parameters})
        {{
            return {parameterNames}.SelectMany(t => Observable.FromAsync(async () => await {qualifiedPrefix}.{method.Identifier}(t)));
        }}",
            (ParamCount.Many, ReturnType.TaskSingle) => @$"public static IObservable<{returnType}> {method.Identifier}_Obs({parameters})
        {{
            return ObservableEx.Zip({parameterNames}).Select(t => t.ToTuple()).SelectMany(t => Observable.FromAsync(async () => await {qualifiedPrefix}.{method.Identifier}({methodCallParams})));
        }}",
            (ParamCount.Zero, ReturnType.TaskSingle) => @$"public static IObservable<{returnType}> {method.Identifier}_Obs()
        {{
            return Observable.FromAsync(async () => await {qualifiedPrefix}.{method.Identifier}());
        }}",


            (ParamCount.One, ReturnType.TaskVoid) => @$"public static IObservable<Unit> {method.Identifier}_Obs({parameters})
        {{
            return {parameterNames}.SelectMany(t => Observable.FromAsync(async () => await {qualifiedPrefix}.{method.Identifier}(t)));
        }}",
            (ParamCount.Many, ReturnType.TaskVoid) => @$"public static IObservable<Unit> {method.Identifier}_Obs({parameters})
        {{
            return ObservableEx.Zip({parameterNames}).Select(t => t.ToTuple()).SelectMany(t => Observable.FromAsync(async () => await {qualifiedPrefix}.{method.Identifier}({methodCallParams})));
        }}",
            (ParamCount.Zero, ReturnType.TaskVoid) => @$"public static IObservable<Unit> {method.Identifier}_Obs()
        {{
            return Observable.FromAsync(async () => await {qualifiedPrefix}.{method.Identifier}());
        }}",


            (ParamCount.One, ReturnType.TaskTuple) => @$"public static {returnType} {method.Identifier}_Obs({parameters})
        {{
            return {parameterNames}.SelectMany(t => Observable.FromAsync(async () => await {qualifiedPrefix}.{method.Identifier}(t))).Unzip(replay: true);
        }}",
            (ParamCount.Many, ReturnType.TaskTuple) => @$"public static {returnType} {method.Identifier}_Obs({parameters})
        {{
            return ObservableEx.Zip({parameterNames}).Select(t => t.ToTuple()).SelectMany(t => Observable.FromAsync(async () => await {qualifiedPrefix}.{method.Identifier}({methodCallParams}))).Unzip(replay: true);
        }}",
            (ParamCount.Zero, ReturnType.TaskTuple) => @$"public static {returnType} {method.Identifier}_Obs()
        {{
            return Observable.FromAsync(async () => await {qualifiedPrefix}.{method.Identifier}()).Unzip(replay: true);
        }}",
        };

        return methodString;
    }

    private enum MethodType
    {
        Static = 0,
        Instance,
    }

    private enum ParamCount
    {
        Zero = 0,
        One,
        Many,
    }

    private enum ReturnType
    {
        Unknown = 0,
        Void,
        Single,
        Tuple,
        TaskVoid,
        TaskSingle,
        TaskTuple,
    }

    private static ImmutableArray<MethodDeclarationSyntax> GetFunctoidMethods(Compilation compilation)
    {
        // Get all classes
        IEnumerable<SyntaxNode> allNodes = compilation.SyntaxTrees.SelectMany(s => s.GetRoot().DescendantNodes());
        IEnumerable<MethodDeclarationSyntax> allMethods = allNodes
            .Where(d => d.IsKind(SyntaxKind.MethodDeclaration))
            .OfType<MethodDeclarationSyntax>();

        return allMethods
            .Select(component => (component, TryGetAttribute(compilation, component)))
            .Where(attr => attr.Item2 is not null)
            .Select(t => t.component)
            .ToImmutableArray();
    }

    private static AttributeSyntax? TryGetAttribute(Compilation compilation, MethodDeclarationSyntax component)
    {
        List<AttributeSyntax> attributes = component.AttributeLists
            .SelectMany(x => x.Attributes)
            .Where(attr =>
                attr.Name.ToString() == FunctoidAttributeName)
            .ToList();

        AttributeSyntax functoidAttribute = attributes.FirstOrDefault(attr => attr.Name.ToString() == FunctoidAttributeName);

        return functoidAttribute is null ? null : functoidAttribute;
    }
}

